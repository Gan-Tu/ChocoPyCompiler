import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ...
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the ending location of a function body.
     *  Because `pass` statements are ignored, we may end up with empty declarations
     *  and statements in a non-empty function body. In this case, we will
     *  return the location just before the function body starts (which should be
     *  the ending location of the INDENT token).
     */
    ComplexSymbolFactory.Location getFunctionBodyEnd(Location functionBodyStart,
                                                     Location functionBodyEnd,
                                                     List<Declaration> declarations,
                                                     List<Stmt> statements) {
      if (statements.isEmpty()) {
        // Since statements must have at least one element in the
        // grammar, if statements is empty this means that these
        // statements can only be made up of one or more passes.
        if (declarations.isEmpty()) {
          return new ComplexSymbolFactory.Location(functionBodyStart.getLine(),
                                                   functionBodyStart.getColumn() - 1);
        } else {
            // When there are declarations and the statements are made up of one or
            // more passes, then the location of the function body end depends on the
            // type of the last declaration.
            Declaration lastDeclaration = declarations.get(declarations.size() - 1);

            // If the last declaration is a function definition, then the end is
            // the end of the last indent of the sequence of one or more pass
            // statements.
            // To get the indentation level we consult the function body start, which
            // begins at a column with the indentation of the function body, less one
            // to move the location back into the indent instead of the first character
            // of the function body.
            // To get the line, we consult the function body end, which must be the
            // line containing the last pass statement
            if (lastDeclaration instanceof FuncDef) {
              return new ComplexSymbolFactory.Location(functionBodyEnd.getLine(),
                                                       functionBodyStart.getColumn() - 1);
            }

            // Otherwise, the end is on the same line as the last declaration,
            // at the position of the newline character, but not going past
            // into the next line.
            Location declarationEnd = getRight(declarations);
            return new ComplexSymbolFactory.Location(declarationEnd.getLine(),
                                                     declarationEnd.getColumn() + 1);
        }
      } else {
        return getRight(statements);
      }
    }

    /** Return the ending location of a block.
     *  Unlike function body, blocks begin with a NEWLINE, so we will return the
     *  ending location of the NEWLINE, instead of the INDENT, for blocks.
     */
    ComplexSymbolFactory.Location getBlockBodyEnd(Location left, List<Stmt> nodes) {
      return nodes.isEmpty() ? left : getRight(nodes);
    }

    /** Recursively desugars the Chocopy if/elif/else syntax and
     *  turn multiple elif/else statements into nested if/else statements.
     */
    List<Stmt> getElseBody(List<IfStmt> elseIfs, List<Stmt> elseBody) {
        if (elseBody == null) {
            elseBody = empty();
        }

        if (elseIfs.isEmpty()) {
          return elseBody;
        }

        IfStmt head = elseIfs.get(0);
        List<IfStmt> tail = elseIfs.subList(1, elseIfs.size());

        // recurse
        return single(new IfStmt(getLeft(elseIfs),
                                 elseBody.isEmpty() ? getRight(elseIfs) : getRight(elseBody),
                                 head.condition,
                                 head.thenBody,
                                 getElseBody(tail, elseBody)));
    }

    /** Return the ending location of the elif/else section of if/elif/else syntax.
     *  - We return the end location of elseBody if it exits and is NOT only a list
     *  of `pass` statements (as expected from reference implementation's behavior).
     *  - Otherwise, we return the end location of elseIfs if it exits. We do not
     *  have to worry about elseIf containing `pass` here, because our elseIf is
     *  represented as a list of IfStmt, which recursively should take of the location
     *  correctly, based on implementation of the grammar.
     *  - Otherwise, we return the end location of the if's thenBody, if it exists
     *  and is NOT only a list of `pass` statements. Otherwise, we shall return
     *  the end location of NEWLINE token, at just before this thenBody block started.
     */
    ComplexSymbolFactory.Location getElseBodyEnd(Location left,
                                                 List<Stmt> thenBody,
                                                 List<IfStmt> elseIfs,
                                                 List<Stmt> elseBody) {

        // elseBody is non-empty and non-pass-only
        if (elseBody != null && !elseBody.isEmpty()) {
            return getRight(elseBody);
        }

        return elseIfs.isEmpty() ? getBlockBodyEnd(left, thenBody) : getRight(elseIfs);
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    /** Return the rightmost non-whitespace location in NODES, or null if
     *  NODES is empty.  Assumes that the nodes of NODES are ordered in
     *  increasing order of location, from left to right. */
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size() - 1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }
:}




/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
terminal UNRECOGNIZED;

/* Literals */
terminal Integer INTEGER;
terminal String STRING;
terminal String IDSTRING;

/* Identifier token, returned by the lexer. */
terminal String IDENTIFIER;

/* Keywords returned by the lexer. */
terminal String AND;
terminal String AS;
terminal String ASSERT;
terminal String ASYNC;
terminal String AWAIT;
terminal String BREAK;
terminal String CLASS;
terminal String CONTINUE;
terminal String DEF;
terminal String DEL;
terminal String ELIF;
terminal String ELSE;
terminal String EXCEPT;
terminal String FALSE;
terminal String FINALLY;
terminal String FOR;
terminal String FROM;
terminal String GLOBAL;
terminal String IF;
terminal String IMPORT;
terminal String IN;
terminal String LAMBDA;
terminal String NEWLINE;
terminal String NONE;
terminal String NONLOCAL;
terminal String NOT;
terminal String OR;
terminal String PASS;
terminal String RAISE;
terminal String RETURN;
terminal String TRUE;
terminal String TRY;
terminal String WHILE;
terminal String WITH;
terminal String YIELD;

/* Operators returned by the lexer. */
terminal String ARROW;
terminal String COLON;
terminal String COMMA;
terminal String DOT;
terminal String EQ;
terminal String EQEQ;
terminal String GEQ;
terminal String GT;
terminal String IDIV;
terminal String IS;
terminal String LEQ;
terminal String LINDEX;
terminal String LPAREN;
terminal String LT;
terminal String MINUS;
terminal String MOD;
terminal String NEQ;
terminal String PLUS;
terminal String RINDEX;
terminal String RPAREN;
terminal String TIMES;

/* Indentation Tokens */
terminal INDENT;
terminal DEDENT;

/* Unary */
terminal UNARY;


/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols,
 *     non terminal <type> <identifier1>, ..., <identifiern>;
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */


/* Program Nonterminal */
non terminal Program           program;

/* Statement Nonterminals */
non terminal List<Stmt>        stmt_list, opt_stmt_list;
non terminal Stmt              simple_stmt, stmt, expr_stmt;
non terminal IfStmt            elif_stmt;
non terminal List<IfStmt>      elif_stmt_list, opt_elif_stmt_list;
non terminal List<Stmt>        else_stmt;
non terminal List<Stmt>        block;

/* Declaration Nonterminals */
non terminal List<Declaration> decl_list, func_decl_list, class_decl_list, opt_class_decl_list;
non terminal Declaration       decl, func_decl, class_decl;
non terminal VarDef            var_def;
non terminal GlobalDecl        global_decl;
non terminal NonLocalDecl      nonlocal_decl;

/* Type Nonterminals */
non terminal TypedVar          typed_var;
non terminal List<TypedVar>    typed_var_list, opt_typed_var_list;
non terminal TypeAnnotation    type;
non terminal ClassType         class_type;
non terminal ListType          list_type;

/* Expression Nonterminals */
non terminal List<Expr>        expr_list, opt_expr_list, target_list;
non terminal Expr              cexpr, expr, target;
non terminal Expr              cexpr_t, expr_t;
non terminal BinaryExpr        binary_expr;
non terminal MemberExpr        member_expr;
non terminal IndexExpr         index_expr;

/* Class nonterminals */
non terminal ClassDef          class_def;
non terminal List<Declaration> class_body;

/* Function Nonterminals */
non terminal FuncDef           func_def, func_body;
non terminal TypeAnnotation    func_return;

/* Other Nonterminals */
non terminal Literal           literal;
non terminal Identifier        identifier;



/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence left IF, ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc EQEQ, NEQ, LT, GT, LEQ, GEQ, IS;
precedence left PLUS, MINUS;
precedence left TIMES, IDIV, MOD;
precedence left UNARY;
precedence left DOT, LINDEX, RINDEX;

/* The start symbol. */
start with program;



/*****  GRAMMAR RULES *****/


/* Program Definitions */

program ::= opt_stmt_list:s
                {: RESULT = new Program(getLeft(s), getRight(s),
                                        empty(), s, errors); :}
          | decl_list:d opt_stmt_list:s
                {: RESULT = new Program(getLeft(d), s.isEmpty()? getRight(d) : getRight(s),
                                        d, s, errors); :}
          | error program:p {: RESULT = p; :}
          ;


/* Declarations */

decl_list ::= decl:d                                {: RESULT = single(d); :}
            | decl_list:l decl:d                    {: RESULT = combine(l, d); :}
            | decl_list:l error                     {: RESULT = l; :}
            ;

decl ::= var_def:v                                  {: RESULT = v; :}
       | func_def:f                                 {: RESULT = f; :}
       | class_def:c                                {: RESULT = c; :}
       ;

func_decl_list ::= func_decl:d                      {: RESULT = single(d); :}
                 | func_decl_list:l func_decl:d     {: RESULT = combine(l, d); :}
                 | func_decl_list:l error           {: RESULT = l; :}
                 ;

func_decl ::= var_def:v                             {: RESULT = v; :}
            | func_def:f                            {: RESULT = f; :}
            | global_decl:g                         {: RESULT = g; :}
            | nonlocal_decl:n                       {: RESULT = n; :}
            ;

opt_class_decl_list ::= class_decl_list:cdl         {: RESULT = cdl; :}
                      |                             {: RESULT = empty(); :}
                      ;

class_decl_list ::= class_decl:d                    {: RESULT = single(d); :}
                  | class_decl_list:l class_decl:d  {: RESULT = combine(l, d); :}
                  | class_decl_list:l error         {: RESULT = l; :}
                  ;

class_decl ::= var_def:v                            {: RESULT = v; :}
             | func_def:f                           {: RESULT = f; :}
             ;


global_decl ::= GLOBAL:x identifier:i NEWLINE
                                      {: RESULT = new GlobalDecl(xxleft, ixright, i); :}
              ;

nonlocal_decl ::= NONLOCAL:x identifier:i NEWLINE
                                      {: RESULT = new NonLocalDecl(xxleft, ixright, i); :}
              ;


/* Variable Declarations */

var_def ::= typed_var:t EQ:op literal:l NEWLINE
                                     {: RESULT = new VarDef(txleft, lxright,
                                                            t, l); :}
          ;

typed_var ::= identifier:i COLON:c type:t                 {: RESULT = new TypedVar(ixleft, txright, i, t); :}
            ;

opt_typed_var_list ::=                                    {: RESULT = empty(); :}
                     | typed_var_list:tvr                 {: RESULT = tvr; :}
                     ;

typed_var_list ::= typed_var:tv                           {: RESULT = single(tv); :}
                 | typed_var_list:tvs COMMA typed_var:tv  {: RESULT = combine(tvs, tv); :}
                 ;

// Function Declarations

func_def ::= DEF:def identifier:id
             LPAREN opt_typed_var_list:var_lst RPAREN:rp func_return:r COLON:c NEWLINE
             INDENT func_body:fb DEDENT
                    {: RESULT = new FuncDef(defxleft,
                                            getFunctionBodyEnd(fbxleft, fbxright, fb.declarations, fb.statements),
                                            id,
                                            var_lst,
                                            r == null ? new ClassType(cxleft, cxleft, "<None>") : r,
                                            fb.declarations,
                                            fb.statements); :}
           ;

func_return ::= ARROW:a type:t  {: RESULT = t; :}
            |                   {: RESULT = null; :}
            ;

func_body ::= func_decl_list:ds stmt_list:ss
                              {: RESULT = new FuncDef(null, null, null, null, null, ds, ss); :}
            | stmt_list:ss
                              {: RESULT = new FuncDef(null, null, null, null, null, empty(), ss); :}
            | error func_body:fb
                              {: RESULT = fb; :}
            ;

// Classes
class_def ::= CLASS:cls identifier:idn LPAREN identifier:ids RPAREN COLON:c NEWLINE
              INDENT class_body:cb DEDENT
                {: RESULT = new ClassDef(clsxleft, cb.isEmpty() ? cxright : getRight(cb), idn, ids, cb); :}
            ;

class_body ::= opt_class_decl_list:ocdl {: RESULT = ocdl; :}
             | error class_body:cb      {: RESULT = cb; :}
             | PASS NEWLINE             {: RESULT = empty(); :}
             ;

// Types

type ::= class_type:c                   {: RESULT = c; :}
       | list_type:l                    {: RESULT = l; :}
       ;

// Note that the class_type accepts identifier as a string token, not AST node
class_type ::= IDENTIFIER:i             {: RESULT = new ClassType(ixleft, ixright, i); :}
             | IDSTRING:s               {: RESULT = new ClassType(sxleft, sxright, s); :}
             ;

list_type ::= LINDEX:l type:t RINDEX:r
                                        {: RESULT = new ListType(lxleft, rxright, t); :}
            ;


/* Blocks */

block ::= NEWLINE INDENT stmt_list:ss DEDENT   {: RESULT = ss; :}
        ;

/* Statements */

opt_stmt_list ::=                              {: RESULT = empty(); :}
                | stmt_list:s                  {: RESULT = s; :}
                ;

stmt_list ::= stmt:s                           {: RESULT = single(s); :}
            | stmt_list:l stmt:s               {: RESULT = combine(l, s); :}
            | stmt_list:l error                {: RESULT = l; :}
            ;

stmt ::= simple_stmt:s NEWLINE                 {: RESULT = s; :}
       | WHILE:w expr:e COLON:c block:b
                                               {: RESULT = new WhileStmt(wxleft,
                                                                         getBlockBodyEnd(cxright, b),
                                                                         e,
                                                                         b); :}
       | FOR:f identifier:id IN:i expr:e COLON:c block:b
                                               {: RESULT = new ForStmt(fxleft,
                                                                       getBlockBodyEnd(cxright, b),
                                                                       id,
                                                                       e,
                                                                       b); :}
       | IF:i expr:e COLON:c block:b opt_elif_stmt_list:elifs else_stmt:els
                                               {: RESULT = new IfStmt(ixleft,
                                                                      getElseBodyEnd(cxright, b, elifs, els),
                                                                      e,
                                                                      b,
                                                                      getElseBody(elifs, els)); :}
       ;


opt_elif_stmt_list ::=                                    {: RESULT = empty(); :}
                     | elif_stmt_list:eliflist            {: RESULT = eliflist; :}
                     ;

elif_stmt_list ::= elif_stmt:elif                         {: RESULT = single(elif); :}
                 | elif_stmt_list:eliflist elif_stmt:elif {: RESULT = combine(eliflist, elif); :}
                 ;

elif_stmt ::= ELIF:elif expr:e COLON:c block:b {: RESULT = new IfStmt(elifxleft, getBlockBodyEnd(cxright, b), e, b, null); :}
            ;


else_stmt ::= ELSE COLON block:b        {: RESULT = b; :}
            |                           {: RESULT = null; :}
            ;

simple_stmt ::= PASS                    {: RESULT = null; :}
              | RETURN:r                {: RESULT = new ReturnStmt(rxleft, rxright,
                                                                  null); :}
              | RETURN:r expr:e         {: RESULT = new ReturnStmt(rxleft, exright,
                                                                  e); :}
              | target_list:t expr:e    {: RESULT = new AssignStmt(txleft, exright,
                                                                  t, e); :}
              | expr_stmt:e             {: RESULT = e; :}
              ;

expr_stmt ::= expr:e    {: RESULT = new ExprStmt(exleft, exright, e); :}
            ;


/* Expressions */
opt_expr_list ::= expr_list:el                {: RESULT = el; :}
                |                             {: RESULT = empty(); :}
                ;

expr_list ::= expr:e                          {: RESULT = single(e); :}
            | expr_list:es COMMA expr:e       {: RESULT = combine(es, e); :}
            ;

expr ::= expr_t:e                             {: RESULT = e; :}
       | expr:e1 AND:op expr:e2               {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
       | expr:e1 OR:op expr:e2                {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
       | expr:then IF expr:con ELSE expr:els
                                              {: RESULT = new IfExpr(thenxleft, elsxright, con, then, els); :}
       ;

expr_t ::= cexpr:e                            {: RESULT = e; :}
         | NOT:n expr_t:e                     {: RESULT = new UnaryExpr(nxleft, exright, n, e); :}
         ;


cexpr ::= cexpr_t:e                           {: RESULT = e; :}
        | binary_expr:e                       {: RESULT = e; :}
        // more...
        ;

cexpr_t ::= identifier:i                      {: RESULT = i; :}
          | literal:l                         {: RESULT = l; :}
          | LINDEX:l opt_expr_list:el RINDEX:r
                                              {: RESULT = new ListExpr(lxleft, rxright, el); :}
          | LPAREN:l expr:e RPAREN: r         {: RESULT = e; :}
          | member_expr:e                     {: RESULT = e; :}
          | index_expr:e                      {: RESULT = e; :}
          | member_expr:e LPAREN:l opt_expr_list:el RPAREN: r
                                              {: RESULT = new MethodCallExpr(exleft, rxright, e, el); :}
          | identifier:i  LPAREN:l opt_expr_list:el RPAREN: r
                                              {: RESULT = new CallExpr(ixleft, rxright, i, el); :}
          | MINUS:op cexpr:e                  {: RESULT = new UnaryExpr(opxleft, exright, op, e); :}
                                          %prec UNARY
          ;

// Specialized Expressions

target_list ::= target:t                {: RESULT = single(t); :}
              | target_list:l target:t  {: RESULT = combine(l, t); :}
              ;

target ::= identifier:i EQ              {: RESULT = i; :}
         | member_expr:e EQ             {: RESULT = e; :}
         | index_expr:e EQ              {: RESULT = e; :}
         ;

member_expr ::= cexpr_t:e DOT identifier:i
                    {: RESULT = new MemberExpr(exleft, ixright, e, i); :}
             ;

index_expr ::= cexpr_t:e LINDEX:l expr:e2 RINDEX:r
                    {: RESULT = new IndexExpr(exleft, rxright, e, e2); :}
             ;


/* A binary expression, illustrating how to find the left and right
 * source position of a phrase. */
binary_expr ::= cexpr:e1 PLUS:op cexpr:e2      {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | cexpr:e1 MINUS:op cexpr:e2     {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | cexpr:e1 TIMES:op cexpr:e2     {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | cexpr:e1 IDIV:op cexpr:e2      {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | cexpr:e1 MOD:op cexpr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 EQEQ:op cexpr:e2      {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 NEQ:op cexpr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 LEQ:op cexpr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 GEQ:op cexpr:e2       {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 LT:op cexpr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 GT:op cexpr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              | cexpr:e1 IS:op cexpr:e2        {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op , e2); :}
              ;

/* An identifier, as defined in the ChocoPy Syntax
 * This is **different** from Lexer token Identifier.
 * It is constructed as a node, as necessary to construct other AST node.
 */
identifier ::= IDENTIFIER:i   {: RESULT = new Identifier(ixleft, ixright, i); :}
            ;

/* A literal, as defined in the ChocoPy syntax */
literal ::= NONE:n      {: RESULT = new NoneLiteral(nxleft, nxright); :}
          | TRUE:b      {: RESULT = new BooleanLiteral(bxleft, bxright, true); :}
          | FALSE:b     {: RESULT = new BooleanLiteral(bxleft, bxright, false); :}
          | INTEGER:n   {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
          | STRING:s    {: RESULT = new StringLiteral(sxleft, sxright, s); :}
          | IDSTRING:s  {: RESULT = new StringLiteral(sxleft, sxright, s); :}
          ;


